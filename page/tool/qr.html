<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Code Generator</title>
  <!-- qrcode.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>
<body>

<!-- ===== 控制面板 ===== -->
<div id="qrg-panel">

  <!-- 内容输入 -->
  <div class="qrg-group">
    <label for="qrg-content">内容</label>
    <textarea id="qrg-content" rows="3" placeholder="输入文字、URL、vCard..."></textarea>
  </div>

  <!-- 格式 / 纠错 -->
  <div class="qrg-group">
    <label for="qrg-ecl">纠错级别</label>
    <select id="qrg-ecl">
      <option value="L">L（7%）</option>
      <option value="M" selected>M（15%）</option>
      <option value="Q">Q（25%）</option>
      <option value="H">H（30%）</option>
    </select>
  </div>

  <!-- 尺寸 -->
  <div class="qrg-group">
    <label for="qrg-size">二维码尺寸 <span id="qrg-size-val">300</span> px</label>
    <input type="range" id="qrg-size" min="100" max="1000" value="300" step="10">
  </div>

  <!-- 外边距 -->
  <div class="qrg-group">
    <label for="qrg-margin">外边距 <span id="qrg-margin-val">10</span> px</label>
    <input type="range" id="qrg-margin" min="0" max="80" value="10" step="1">
  </div>

  <!-- 颜色 -->
  <div class="qrg-group">
    <label>前景色（码点）</label>
    <input type="color" id="qrg-fgcolor" value="#000000">
  </div>
  <div class="qrg-group">
    <label>背景色</label>
    <input type="color" id="qrg-bgcolor" value="#ffffff">
  </div>

  <!-- 渐变（可选） -->
  <div class="qrg-group">
    <label><input type="checkbox" id="qrg-gradient-on"> 启用渐变前景色</label>
    <div id="qrg-gradient-opts" style="display:none; margin-top:6px;">
      <label>渐变色 2</label>
      <input type="color" id="qrg-fgcolor2" value="#0066cc">
      <label>渐变方向</label>
      <select id="qrg-gradient-dir">
        <option value="lr">从左到右</option>
        <option value="tb">从上到下</option>
        <option value="diag">对角线</option>
        <option value="radial">径向</option>
      </select>
    </div>
  </div>

  <!-- 圆角 -->
  <div class="qrg-group">
    <label for="qrg-radius">码点圆角 <span id="qrg-radius-val">0</span>%</label>
    <input type="range" id="qrg-radius" min="0" max="50" value="0" step="1">
  </div>

  <!-- 定位角（Finder Pattern）颜色 -->
  <div class="qrg-group">
    <label><input type="checkbox" id="qrg-finder-custom"> 自定义定位角颜色</label>
    <div id="qrg-finder-opts" style="display:none; margin-top:6px;">
      <label>外框颜色</label>
      <input type="color" id="qrg-finder-outer" value="#000000">
      <label>内点颜色</label>
      <input type="color" id="qrg-finder-inner" value="#000000">
    </div>
  </div>

  <!-- 中心 Logo -->
  <div class="qrg-group">
    <label for="qrg-logo">中心图片（Logo）</label>
    <input type="file" id="qrg-logo" accept="image/*">
    <label for="qrg-logo-size">Logo 大小 <span id="qrg-logo-size-val">25</span>%</label>
    <input type="range" id="qrg-logo-size" min="5" max="40" value="25" step="1">
    <label for="qrg-logo-radius">Logo 圆角 <span id="qrg-logo-radius-val">8</span> px</label>
    <input type="range" id="qrg-logo-radius" min="0" max="60" value="8" step="1">
    <label><input type="checkbox" id="qrg-logo-bg" checked> Logo 白色背景衬底</label>
    <button id="qrg-logo-clear">清除 Logo</button>
  </div>

  <!-- 水印文字 -->
  <div class="qrg-group">
    <label for="qrg-watermark">底部水印文字（可选）</label>
    <input type="text" id="qrg-watermark" placeholder="例：扫码关注">
    <label for="qrg-wm-size">字号 <span id="qrg-wm-size-val">16</span> px</label>
    <input type="range" id="qrg-wm-size" min="8" max="48" value="16" step="1">
    <label>水印颜色</label>
    <input type="color" id="qrg-wm-color" value="#333333">
  </div>

  <!-- 生成按钮 -->
  <button id="qrg-generate">生 成 二 维 码</button>

  <!-- 下载 -->
  <div id="qrg-download-row" style="display:none; margin-top:12px;">
    <button id="qrg-dl-png">下载 PNG</button>
    <button id="qrg-dl-jpg">下载 JPG</button>
    <button id="qrg-dl-svg">下载 SVG</button>
    <button id="qrg-dl-webp">下载 WebP</button>
  </div>
</div>

<!-- ===== 预览区 ===== -->
<div id="qrg-preview">
  <canvas id="qrg-canvas"></canvas>
  <p id="qrg-hint">点击「生成二维码」查看预览</p>
</div>

<!-- ===== 隐藏的 qrcode.js 渲染容器 ===== -->
<div id="qrg-hidden" style="position:fixed;left:-9999px;top:-9999px;visibility:hidden;"></div>


<script>
(function () {
  'use strict';

  /* ---- 工具 ---- */
  const $ = id => document.getElementById(id);
  const bindRange = (id, displayId) => {
    const el = $(id), dsp = $(displayId);
    el.addEventListener('input', () => { dsp.textContent = el.value; });
  };

  /* ---- 状态 ---- */
  let logoDataURL = null;

  /* ---- 绑定范围显示 ---- */
  bindRange('qrg-size',         'qrg-size-val');
  bindRange('qrg-margin',       'qrg-margin-val');
  bindRange('qrg-radius',       'qrg-radius-val');
  bindRange('qrg-logo-size',    'qrg-logo-size-val');
  bindRange('qrg-logo-radius',  'qrg-logo-radius-val');
  bindRange('qrg-wm-size',      'qrg-wm-size-val');

  /* ---- 渐变 toggle ---- */
  $('qrg-gradient-on').addEventListener('change', function () {
    $('qrg-gradient-opts').style.display = this.checked ? 'block' : 'none';
  });

  /* ---- 定位角 toggle ---- */
  $('qrg-finder-custom').addEventListener('change', function () {
    $('qrg-finder-opts').style.display = this.checked ? 'block' : 'none';
  });

  /* ---- Logo 上传 ---- */
  $('qrg-logo').addEventListener('change', function () {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => { logoDataURL = e.target.result; };
    reader.readAsDataURL(file);
  });

  $('qrg-logo-clear').addEventListener('click', () => {
    logoDataURL = null;
    $('qrg-logo').value = '';
  });

  /* ---- 核心渲染 ---- */
  function generate() {
    const content = $('qrg-content').value.trim();
    if (!content) { alert('请输入二维码内容！'); return; }

    const size       = parseInt($('qrg-size').value);
    const margin     = parseInt($('qrg-margin').value);
    const ecl        = $('qrg-ecl').value;
    const fgColor    = $('qrg-fgcolor').value;
    const bgColor    = $('qrg-bgcolor').value;
    const radius     = parseInt($('qrg-radius').value) / 100;  // 0-0.5
    const gradOn     = $('qrg-gradient-on').checked;
    const fgColor2   = $('qrg-fgcolor2').value;
    const gradDir    = $('qrg-gradient-dir').value;
    const finderCust = $('qrg-finder-custom').checked;
    const finderOuter= $('qrg-finder-outer').value;
    const finderInner= $('qrg-finder-inner').value;
    const logoSize   = parseInt($('qrg-logo-size').value) / 100;
    const logoRadius = parseInt($('qrg-logo-radius').value);
    const logoBg     = $('qrg-logo-bg').checked;
    const watermark  = $('qrg-watermark').value.trim();
    const wmSize     = parseInt($('qrg-wm-size').value);
    const wmColor    = $('qrg-wm-color').value;

    /* Step 1: 用 qrcode.js 生成原始 QR bitmap */
    const hidden = $('qrg-hidden');
    hidden.innerHTML = '';
    const tempDiv = document.createElement('div');
    hidden.appendChild(tempDiv);

    const eclMap = { L: QRCode.CorrectLevel.L, M: QRCode.CorrectLevel.M, Q: QRCode.CorrectLevel.Q, H: QRCode.CorrectLevel.H };

    // qrcode.js 用 canvas 或 img，我们用 canvas 模式
    const qr = new QRCode(tempDiv, {
      text: content,
      width: size,
      height: size,
      colorDark: '#000000',
      colorLight: '#ffffff',
      correctLevel: eclMap[ecl]
    });

    // 等待 qrcode.js 渲染
    setTimeout(() => {
      try {
        const srcCanvas = tempDiv.querySelector('canvas');
        if (!srcCanvas) { alert('生成失败，请检查输入内容。'); return; }

        /* Step 2: 读取模块矩阵 */
        const modules = getModules(srcCanvas);
        const N = modules.length;

        /* Step 3: 自定义绘制到目标 canvas */
        const wmHeight = watermark ? wmSize + 10 : 0;
        const totalH   = size + margin * 2 + wmHeight;
        const canvas   = $('qrg-canvas');
        canvas.width   = size + margin * 2;
        canvas.height  = totalH;
        const ctx      = canvas.getContext('2d');

        // 背景
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 前景渐变或纯色
        let fgPaint;
        if (gradOn) {
          fgPaint = makeGradient(ctx, gradDir, size, margin, fgColor, fgColor2);
        } else {
          fgPaint = fgColor;
        }

        const cellW = size / N;
        const cellH = size / N;

        // 识别 Finder Pattern 位置（左上/右上/左下）
        const finderCells = finderCust ? getFinderCells(N) : new Set();

        // 绘制每个模块
        for (let r = 0; r < N; r++) {
          for (let c = 0; c < N; c++) {
            if (!modules[r][c]) continue;

            const x = margin + c * cellW;
            const y = margin + r * cellH;
            const key = `${r},${c}`;

            let color = fgPaint;
            if (finderCust && finderCells.has(key)) {
              // 判断是外框还是内点
              color = isFinderInner(r, c, N) ? finderInner : finderOuter;
            }

            drawCell(ctx, x, y, cellW, cellH, radius, color);
          }
        }

        // 水印
        if (watermark) {
          ctx.font = `bold ${wmSize}px sans-serif`;
          ctx.fillStyle = wmColor;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(watermark, canvas.width / 2, size + margin * 2 + wmHeight / 2);
        }

        // Logo
        if (logoDataURL) {
          drawLogo(ctx, logoDataURL, margin, size, logoSize, logoRadius, logoBg, () => {
            showPreview(canvas);
          });
        } else {
          showPreview(canvas);
        }

      } catch (e) {
        console.error(e);
        alert('生成出错：' + e.message);
      }
    }, 100);
  }

  /* 从 qrcode.js 的 canvas 中读取黑/白模块矩阵 */
  function getModules(srcCanvas) {
    const ctx = srcCanvas.getContext('2d');
    const w = srcCanvas.width;
    const h = srcCanvas.height;
    const data = ctx.getImageData(0, 0, w, h).data;
    const N = Math.round(Math.sqrt((w * h) / (w * h)) * w / (w / Math.round(w / (w / Math.floor(w / 21)))));
    // 实际上我们直接按像素采样推断模块数
    // 找到最小重复单元（模块大小）
    const moduleSize = detectModuleSize(srcCanvas, data, w, h);
    const cols = Math.round(w / moduleSize);
    const rows = Math.round(h / moduleSize);
    const mods = [];
    for (let r = 0; r < rows; r++) {
      mods[r] = [];
      for (let c = 0; c < cols; c++) {
        const px = Math.round((c + 0.5) * moduleSize);
        const py = Math.round((r + 0.5) * moduleSize);
        const idx = (py * w + px) * 4;
        mods[r][c] = data[idx] < 128; // dark = true
      }
    }
    return mods;
  }

  function detectModuleSize(canvas, data, w, h) {
    // 扫描第一行找到第一个黑色像素列，然后找第一段白色来推算
    const row = 0;
    let startDark = -1, endDark = -1;
    for (let x = 0; x < w; x++) {
      const idx = (row * w + x) * 4;
      const dark = data[idx] < 128;
      if (dark && startDark === -1) startDark = x;
      if (!dark && startDark !== -1) { endDark = x; break; }
    }
    if (startDark === -1 || endDark === -1) return w / 21;
    return endDark - startDark;
  }

  /* Finder Pattern 单元格集合 */
  function getFinderCells(N) {
    const s = new Set();
    const regions = [
      [0, 0], [0, N - 7], [N - 7, 0]
    ];
    regions.forEach(([r0, c0]) => {
      for (let r = r0; r < r0 + 7; r++) {
        for (let c = c0; c < c0 + 7; c++) {
          s.add(`${r},${c}`);
        }
      }
    });
    return s;
  }

  function isFinderInner(r, c, N) {
    const regions = [[0, 0], [0, N - 7], [N - 7, 0]];
    for (const [r0, c0] of regions) {
      const dr = r - r0, dc = c - c0;
      if (dr >= 2 && dr <= 4 && dc >= 2 && dc <= 4) return true;
    }
    return false;
  }

  /* 绘制单个模块（支持圆角） */
  function drawCell(ctx, x, y, w, h, radius, color) {
    ctx.fillStyle = color;
    if (radius <= 0) {
      ctx.fillRect(x, y, w, h);
    } else {
      const r = Math.min(w, h) * radius;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }
  }

  /* 渐变 */
  function makeGradient(ctx, dir, size, margin, c1, c2) {
    let grad;
    const x0 = margin, y0 = margin, x1 = margin + size, y1 = margin + size;
    switch (dir) {
      case 'lr':    grad = ctx.createLinearGradient(x0, y0, x1, y0); break;
      case 'tb':    grad = ctx.createLinearGradient(x0, y0, x0, y1); break;
      case 'diag':  grad = ctx.createLinearGradient(x0, y0, x1, y1); break;
      case 'radial':
        const cx = (x0 + x1) / 2, cy = (y0 + y1) / 2;
        grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size / 2);
        break;
    }
    grad.addColorStop(0, c1);
    grad.addColorStop(1, c2);
    return grad;
  }

  /* 绘制 Logo */
  function drawLogo(ctx, src, margin, size, logoSizeRatio, borderRadius, withBg, cb) {
    const img = new Image();
    img.onload = () => {
      const lw = size * logoSizeRatio;
      const lh = lw * (img.height / img.width);
      const lx = margin + (size - lw) / 2;
      const ly = margin + (size - lh) / 2;

      if (withBg) {
        const pad = 6;
        ctx.save();
        roundRect(ctx, lx - pad, ly - pad, lw + pad * 2, lh + pad * 2, borderRadius + 4);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.restore();
      }

      ctx.save();
      roundRect(ctx, lx, ly, lw, lh, borderRadius);
      ctx.clip();
      ctx.drawImage(img, lx, ly, lw, lh);
      ctx.restore();

      cb();
    };
    img.onerror = () => { cb(); };
    img.src = src;
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  /* 显示预览 */
  function showPreview(canvas) {
    $('qrg-hint').style.display = 'none';
    canvas.style.display = 'block';
    $('qrg-download-row').style.display = 'block';
  }

  /* ---- 下载 ---- */
  function downloadCanvas(type, ext) {
    const canvas = $('qrg-canvas');
    const mime = type === 'image/svg+xml' ? null : type;
    if (!mime) { downloadSVG(); return; }
    canvas.toBlob(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `qrcode.${ext}`;
      a.click();
    }, mime, type === 'image/jpeg' ? 0.95 : undefined);
  }

  function downloadSVG() {
    // 将 canvas 转换为 SVG（embedded image）
    const canvas = $('qrg-canvas');
    const dataURL = canvas.toDataURL('image/png');
    const w = canvas.width, h = canvas.height;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
  <image href="${dataURL}" width="${w}" height="${h}"/>
</svg>`;
    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'qrcode.svg';
    a.click();
  }

  $('qrg-generate').addEventListener('click', generate);
  $('qrg-dl-png').addEventListener('click',  () => downloadCanvas('image/png', 'png'));
  $('qrg-dl-jpg').addEventListener('click',  () => downloadCanvas('image/jpeg', 'jpg'));
  $('qrg-dl-svg').addEventListener('click',  () => downloadCanvas('image/svg+xml', 'svg'));
  $('qrg-dl-webp').addEventListener('click', () => downloadCanvas('image/webp', 'webp'));

  // 初始隐藏 canvas
  $('qrg-canvas').style.display = 'none';

})();
</script>

</body>
</html>
